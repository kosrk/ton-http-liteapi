//go:build ignore

package main

import (
	"bytes"
	"fmt"
	"github.com/kosrk/ton-http-liteapi/utils"
	"github.com/startfellows/tongo/liteclient"
	"go/format"
	"os"
	"regexp"
	"strings"
)

type method struct {
	FunctionName string
	ReqType      any
}

var (
	methods = []method{
		{"LiteServerGetMasterchainInfo", nil},                                                    // liteServer.getMasterchainInfo
		{"LiteServerGetMasterchainInfoExt", liteclient.LiteServerGetMasterchainInfoExtRequest{}}, // liteServer.getMasterchainInfoExt
		{"LiteServerGetTime", nil},                                                               // liteServer.getTime
		{"LiteServerGetBlock", liteclient.LiteServerGetBlockRequest{}},                           // liteServer.getBlock
		{"LiteServerGetState", liteclient.LiteServerGetStateRequest{}},                           // liteServer.getState
		{"LiteServerGetBlockHeader", liteclient.LiteServerGetBlockHeaderRequest{}},               // liteServer.getBlockHeader
		{"LiteServerSendMessage", liteclient.LiteServerSendMessageRequest{}},                     // liteServer.sendMessage
		{"LiteServerGetAccountState", liteclient.LiteServerGetAccountStateRequest{}},             // liteServer.getAccountState
		{"LiteServerGetShardInfo", liteclient.LiteServerGetShardInfoRequest{}},                   // liteServer.getShardInfo
		{"LiteServerGetAllShardsInfo", liteclient.LiteServerGetAllShardsInfoRequest{}},           // liteServer.getAllShardsInfo
		{"LiteServerGetTransactions", liteclient.LiteServerGetTransactionsRequest{}},             // liteServer.getTransactions
		{"LiteServerListBlockTransactions", liteclient.LiteServerListBlockTransactionsRequest{}}, // liteServer.listBlockTransactions
		{"LiteServerGetBlockProof", liteclient.LiteServerGetBlockProofRequest{}},                 // liteServer.getBlockProof
		{"LiteServerGetConfigAll", liteclient.LiteServerGetConfigAllRequest{}},                   // liteServer.getConfigAll
		{"LiteServerGetShardBlockProof", liteclient.LiteServerGetShardBlockProofRequest{}},       // liteServer.getShardBlockProof
	}
	camelCaseWordBarrierRegex = regexp.MustCompile(`([^A-Z])([A-Z])`)
)

func main() {
	f, err := os.Create("generated.go")
	if err != nil {
		panic(err)
	}

	_, err = fmt.Fprint(f, `
package api
// Code autogenerated. DO NOT EDIT.

import (
	"fmt"
	"github.com/kosrk/ton-http-liteapi/utils"
	log "github.com/sirupsen/logrus"
	"github.com/startfellows/tongo/liteclient"
	"net/http"
)

`)

	if err != nil {
		panic(err)
	}
	builder := strings.Builder{}
	builder.WriteString(buildHandlers())
	builder.WriteRune('\n')
	builder.WriteString(registerHandlers())
	res := builder.String()

	b, err := format.Source([]byte(res))
	if err != nil {
		panic(err)
	}

	_, err = f.WriteString(string(b))
	if err != nil {
		panic(err)
	}

	f1, err := os.Create("template.http")
	if err != nil {
		panic(err)
	}
	builder = strings.Builder{}
	builder.WriteString(buildDoc())
	res = builder.String()
	_, err = f1.WriteString(res)
	if err != nil {
		panic(err)
	}

}

func buildHandlers() string {
	builder := strings.Builder{}
	for _, m := range methods {
		builder.WriteString(fmt.Sprintf("func (h *Handler) %s(resp http.ResponseWriter, req *http.Request) {\n", m.FunctionName))
		if m.ReqType != nil {
			builder.WriteString(fmt.Sprintf("var request liteclient.%sRequest\n", m.FunctionName))
			builder.WriteString(fmt.Sprintf(`
				err := utils.JsonDecoder(req.Body).Decode(&request)
				if err != nil {
					writeHttpError(resp, http.StatusBadRequest, fmt.Sprintf("decode payload err: %%v", err))
					return
				}
			`))
			builder.WriteString(fmt.Sprintf("response, err := h.blockchain.%s(req.Context(), request)\n", m.FunctionName))
		} else {
			builder.WriteString(fmt.Sprintf("response, err := h.blockchain.%s(req.Context())\n", m.FunctionName))
		}
		builder.WriteString(fmt.Sprintf(`
				if err != nil {
					writeHttpError(resp, http.StatusInternalServerError, fmt.Sprintf("liteserver request err: %%v", err))
					return
				}
				resp.Header().Add("Content-Type", "application/json")
				resp.WriteHeader(http.StatusOK)
				err = utils.JsonEncoder(resp).Encode(response)
				if err != nil {
					log.Errorf("response json encoding error: %%v", err)
				}
			}
		`))
		builder.WriteRune('\n')
	}
	return builder.String()
}

func registerHandlers() string {
	builder := strings.Builder{}
	builder.WriteString("func RegisterHandlers(mux *http.ServeMux, h *Handler) {\n")

	for _, m := range methods {
		builder.WriteString(fmt.Sprintf("mux.HandleFunc(\"/v1/%s\", recoverMiddleware(post(h.%s)))\n",
			toSnakeCase(m.FunctionName), m.FunctionName))
	}
	builder.WriteString("}")
	return builder.String()
}

func buildDoc() string {
	builder := strings.Builder{}
	for _, m := range methods {
		builder.WriteString(fmt.Sprintf("###\nPOST {{url}}/v1/%s\nContent-Type: application/json\n\n",
			toSnakeCase(m.FunctionName)))
		if m.ReqType != nil {
			b := bytes.NewBuffer([]byte{})
			utils.JsonEncoder(b).Encode(m.ReqType)
			builder.WriteString(b.String())
		}

		builder.WriteString("\n")
	}
	return builder.String()
}

func toSnakeCase(x string) string {
	return string(bytes.ToLower(
		camelCaseWordBarrierRegex.ReplaceAll(
			[]byte(x),
			[]byte("${1}_${2}"),
		)))
}
